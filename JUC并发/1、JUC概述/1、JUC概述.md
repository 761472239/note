# 1、JUC概述

## 1.1 JUC简介

JUC是 在Java 5.0添加的 `java.util.concurrent`包的简称，目的就是为了更好的支持高并发任务，让开发者利用这个包进行的多线程编程时可以有效的减少竞争条件和死锁线程。

## 1.2 进程和线程

**进程：** 进程（Process）是计算机中的程序 关于 某个数据集合上的 一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。
**线程：** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。**一个进程有多个线程。**
\*\*总结来说:\*\*
进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。
线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。

## 1.3 线程的状态

### 1.3.1  线程状态枚举类

java.lang.Thread.State

```java
public enum State {
    NEW,(新建)
    RUNNABLE,(准备就绪)
    BLOCKED,(阻塞)
    WAITING,(不见不散)
    TIMED_WAITING,(过时不候)
    TERMINATED;(终结)
}
```

### 1.3.2 wait和sleep的区别

*   sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用

*   sleep不会释放锁，他不需要占用锁；

wait会释放锁，但是调用它的前提是当前线程占有锁（代码在synchronize中）

*   他们都可以被interrupted方法打断

## 1.4 并发与并行

### 1.4.1 串行模式

### 1.4.2 并行模式

### 1.4.3 并发

**并发(concurrent)：** 指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，并发的重点在于它是一种现象，并发描述的是多进程同时运行的现象。但实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的"同时运行"表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会。
**解决问题：** 要解决大并发问题，通常是将大任务分解成多个小任务, 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：

1.  可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用

队列或类似的数据结构来存放各个小任务的成果；

1.  可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或

异步的方式，比如只有准备好产生了事件通知才执行某个任务。

1.  可以多进程/多线程的方式并行执行这些小任务。也可以单进程/单线程执行这

些小任务，这时很可能要配合多路复用才能达到较高的效率。

### 1.4.4 小结

并发：抢票
并行：一遍吃饭，一遍看手机

## 1.5 管程

**管程(monitor)：** 是保证了同一时刻只有一个进程在管程内活动，即管程内定义的操作在同一时刻只被一个进程调用(由编译器实现)。但是这样并不能保证进程以设计的顺序执行，JVM 中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程(monitor)对象，管程(monitor)会随着 java 对象一同创建和销毁，执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方法在执行时候会持有管程，其他线程无法再获取同一个管程。

## 1.6 用户线程和守护线程

用户线程：自定义线程 new Thread

> 主线程结束了，用户线程还会继续运行，JVM存活

守护线程：比如垃圾回收线程

> 没有用户线程，都是守护线程，主线程结束，JVM结束
